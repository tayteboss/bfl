{%- assign exposure_option_index = null -%}
{%- assign selected_exposure_value = null -%}
{%- for option in product.options_with_values -%}
  {%- if option.name == 'Exposures' -%}
    {%- assign exposure_option_index = forloop.index0 -%}
  {%- endif -%}
{%- endfor -%}

{%- if exposure_option_index != null -%}
  {%- if exposure_option_index == 0 -%}
    {%- assign selected_exposure_value = product.selected_or_first_available_variant.option1 -%}
  {%- elsif exposure_option_index == 1 -%}
    {%- assign selected_exposure_value = product.selected_or_first_available_variant.option2 -%}
  {%- else -%}
    {%- assign selected_exposure_value = product.selected_or_first_available_variant.option3 -%}
  {%- endif -%}

  <div
    class="variant-selector"
    data-variant-index="{{ exposure_option_index }}"
    data-form-id="{{ product_form_id }}"
    data-section-id="{{ section_id }}"
  >
    <fieldset class="variant-options">
      <div class="variant-selector__options">
        {%- for option in product.options_with_values -%}
          {%- if option.name == 'Exposures' -%}
            {%- for value in option.values -%}
              {%- assign available_for_value = false -%}
              {%- for v in product.variants -%}
                {%- if exposure_option_index == 0 and v.option1 == value and v.available -%}
                  {%- assign available_for_value = true -%}
                  {%- break -%}
                {%- elsif exposure_option_index == 1 and v.option2 == value and v.available -%}
                  {%- assign available_for_value = true -%}
                  {%- break -%}
                {%- elsif exposure_option_index == 2 and v.option3 == value and v.available -%}
                  {%- assign available_for_value = true -%}
                  {%- break -%}
                {%- endif -%}
              {%- endfor -%}
              <label
                for="Exposure-{{ section_id }}-{{ value | handle }}"
                class="variant-selector__option{% if value == selected_exposure_value %} is-active{% endif %}{% unless available_for_value %} is-unavailable{% endunless %}"
              >
                <div class="product-film-features__hint-value product-film-features__hint-value--bottom">Sold Out</div>
                <input
                  type="radio"
                  id="Exposure-{{ section_id }}-{{ value | handle }}"
                  name="exposure-choice"
                  value="{{ value | escape }}"
                  {% if value == selected_exposure_value %}
                    checked
                  {% endif %}
                  {% unless available_for_value %}
                    disabled
                  {% endunless %}
                >
                <span class="variant-selector__option-label type-h1-small">{{ value }}</span>
                <div class="variant-selector__option-icon">EXP</div>
              </label>
            {%- endfor -%}
          {%- endif -%}
        {%- endfor -%}
      </div>
    </fieldset>
  </div>

  <script type="application/json" id="ProductVariants-{{ section_id }}">
    {{ product.variants | json }}
  </script>

  <script>
    (function () {
      function init() {
        const root = document.getElementById('MainProduct-{{ section_id }}');
        if (!root) return;
        // Find the specific variant selector for exposures by looking for the exposure-choice input
        const exposureInput = root.querySelector('input[name="exposure-choice"]');
        const wrap = exposureInput ? exposureInput.closest('.variant-selector') : null;
        if (!wrap) return;
        const form = document.getElementById('{{ product_form_id }}');
        if (!form) return;
        const idInput = form.querySelector('input[name="id"]');
        if (!idInput) return;
        const variantsEl = document.getElementById('ProductVariants-{{ section_id }}');
        let variants = [];
        try {
          variants = JSON.parse(variantsEl?.textContent || '[]');
        } catch (e) {}
        const exposureIndex = parseInt(wrap.getAttribute('data-variant-index') || '0', 10);
        const optionNames = {{ product.options | json }};

        function getSelectedOptions() {
          return optionNames.map((_, idx) => {
            if (idx === exposureIndex) {
              const r = wrap.querySelector('input[name="exposure-choice"]:checked');
              return r ? r.value : null;
            }
            // Check for other variant selectors (color, size)
            const colorRadio = root.querySelector('input[name="color-choice"]:checked');
            if (colorRadio) {
              const colorWrap = root.querySelector('.variant-selector input[name="color-choice"]');
              if (colorWrap) {
                const colorWrapParent = colorWrap.closest('.variant-selector');
                const colorIndex = parseInt(colorWrapParent?.getAttribute('data-variant-index') || '-1', 10);
                if (idx === colorIndex) {
                  return colorRadio.value;
                }
              }
            }
            const sizeRadio = root.querySelector('input[name="size-choice"]:checked');
            if (sizeRadio) {
              const sizeWrap = root.querySelector('.variant-selector input[name="size-choice"]');
              if (sizeWrap) {
                const sizeWrapParent = sizeWrap.closest('.variant-selector');
                const sizeIndex = parseInt(sizeWrapParent?.getAttribute('data-variant-index') || '-1', 10);
                if (idx === sizeIndex) {
                  return sizeRadio.value;
                }
              }
            }
            const sel = root.querySelector(`#Option-{{ section_id }}-${idx}`);
            return sel ? sel.value : null;
          });
        }

        function findVariantByOptions(selected) {
          if (!Array.isArray(selected) || selected.includes(null)) return null;
          
          // First try to find an available variant that matches all options
          const availableVariant = variants.find((v) => 
            v.available && 
            Array.isArray(v.options) && 
            v.options.every((opt, i) => opt === selected[i])
          );
          
          if (availableVariant) {
            return availableVariant;
          }
          
          // If no available variant, find any matching variant (for display purposes)
          const anyVariant = variants.find((v) => 
            Array.isArray(v.options) && 
            v.options.every((opt, i) => opt === selected[i])
          );
          
          return anyVariant || null;
        }

        function formatCents(cents) {
          const value = (cents || 0) / 100;
          try {
            return new Intl.NumberFormat(undefined, {
              style: 'currency',
              currency: '{{ cart.currency.iso_code }}',
              currencyDisplay: 'symbol',
              minimumFractionDigits: 2,
              maximumFractionDigits: 2,
            }).format(value);
          } catch (e) {
            return `${'{{ cart.currency.symbol }}'}${value.toFixed(2)}`;
          }
        }

        function updateActiveState() {
          wrap.querySelectorAll('.variant-selector__option').forEach((opt) => opt.classList.remove('is-active'));
          const checked = wrap.querySelector('input[name="exposure-choice"]:checked');
          if (checked) checked.closest('.variant-selector__option')?.classList.add('is-active');
        }
        
        function updateAvailabilityState() {
          // Update availability state for all exposure options based on current variants
          wrap.querySelectorAll('.variant-selector__option').forEach((optionEl) => {
            const radio = optionEl.querySelector('input[type="radio"]');
            if (!radio) return;
            
            const exposureValue = radio.value;
            
            // Check if there's any available variant with this exposure
            const hasAvailableVariant = variants.some((v) => {
              if (!v.available) return false;
              if (!Array.isArray(v.options)) return false;
              return v.options[exposureIndex] === exposureValue;
            });
            
            if (hasAvailableVariant) {
              optionEl.classList.remove('is-unavailable');
              radio.disabled = false;
            } else {
              optionEl.classList.add('is-unavailable');
              radio.disabled = true;
              // If this option is checked but unavailable, uncheck it
              if (radio.checked) {
                radio.checked = false;
                // Find and select the first available option
                const firstAvailable = wrap.querySelector('.variant-selector__option:not(.is-unavailable) input[type="radio"]');
                if (firstAvailable) {
                  firstAvailable.checked = true;
                  firstAvailable.dispatchEvent(new Event('change', { bubbles: true }));
                }
              }
            }
          });
        }

        function handleVariantChange() {
          updateActiveState();
          const selected = getSelectedOptions();
          
          const matched = findVariantByOptions(selected);
          
          // If no match OR if matched variant is unavailable, try to find an available variant
          if (!matched || !matched.available) {
            const exposureValue = selected[exposureIndex];
            if (exposureValue) {
              // Find any available variant with the selected exposure
              const availableWithExposure = variants.find((v) => {
                if (!v.available) return false;
                if (!Array.isArray(v.options)) return false;
                return v.options[exposureIndex] === exposureValue;
              });
              
              if (availableWithExposure) {
                // Update other option selects to match this available variant
                let optionsUpdated = false;
                optionNames.forEach((name, idx) => {
                  if (idx !== exposureIndex && availableWithExposure.options[idx]) {
                    const sel = root.querySelector(`#Option-{{ section_id }}-${idx}`);
                    if (sel && sel.value !== availableWithExposure.options[idx]) {
                      sel.value = availableWithExposure.options[idx];
                      optionsUpdated = true;
                    }
                  }
                });
                
                // If we updated options, retry matching
                if (optionsUpdated) {
                  const updatedSelected = getSelectedOptions();
                  const retryMatched = findVariantByOptions(updatedSelected);
                  if (retryMatched && retryMatched.available) {
                    updateVariantUI(retryMatched);
                    return;
                  }
                } else {
                  // Options didn't need updating, use the available variant directly
                  updateVariantUI(availableWithExposure);
                  return;
                }
              } else {
                // Still no available variant - disable button
                if (matched && !matched.available) {
                  updateVariantUI(matched); // Still update UI to show it's unavailable
                  return;
                }
              }
            }
            
            // No match at all - disable button
            if (!matched) {
              const submit = document.getElementById('ProductSubmitButton-{{ section_id }}');
              if (submit) {
                submit.setAttribute('disabled', 'disabled');
                submit.setAttribute('aria-disabled', 'true');
              }
              return;
            }
          }
          
          // Matched variant is available - use it
          updateVariantUI(matched);
        }
        
        function updateVariantUI(matched) {
          // Update variant ID input
          idInput.value = matched.id;
          // Never disable the input - just disable the button if unavailable
          idInput.removeAttribute('disabled');
          idInput.dispatchEvent(new Event('change', { bubbles: true }));

          // Update price in-place (fallback)
          const priceNodes = root.querySelectorAll('.product-content__price .type-p-large');
          const priceEl = priceNodes && priceNodes[priceNodes.length - 1];
          if (priceEl) priceEl.textContent = formatCents(matched.price);

          // Toggle submit button disabled state for UX
          const submit = document.getElementById('ProductSubmitButton-{{ section_id }}');
          if (submit) {
            if (matched.available) {
              submit.removeAttribute('disabled');
              submit.removeAttribute('aria-disabled');
            } else {
              submit.setAttribute('disabled', 'disabled');
              submit.setAttribute('aria-disabled', 'true');
            }
          }
          
          // Ensure form is properly initialized after variant change
          // Check if product-form element exists and re-initialize if needed
          const productForm = form.closest('product-form');
          if (productForm && typeof productForm.initialize === 'function') {
            // Just verify form is still initialized, don't re-init unnecessarily
            if (!productForm._initialized) {
              productForm.initialize();
            }
          }
        }

        // Click the entire option to select
        wrap.querySelectorAll('.variant-selector__option').forEach((opt) => {
          opt.addEventListener('click', (e) => {
            const input = opt.querySelector('input[type="radio"]');
            if (!input || input.disabled) return;
            if (!input.checked) {
              input.checked = true;
              input.dispatchEvent(new Event('change', { bubbles: true }));
            }
          });
        });

        // Bind to radio changes
        wrap.querySelectorAll('input[type="radio"][name="exposure-choice"]').forEach((radio) => {
          radio.addEventListener('change', handleVariantChange);
        });

        // Also react to changes on other option selects
        root.querySelectorAll('select[id^="Option-{{ section_id }}-"]').forEach((sel) => {
          sel.addEventListener('change', () => {
            updateAvailabilityState();
            handleVariantChange();
          });
        });

        // React to changes in other variant selectors (color, size)
        root.querySelectorAll('input[name="color-choice"], input[name="size-choice"]').forEach((radio) => {
          radio.addEventListener('change', () => {
            updateAvailabilityState();
            handleVariantChange();
          });
        });

        // Initialize
        updateAvailabilityState();
        handleVariantChange();
      }

      if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', init, { once: true });
      } else {
        init();
      }
    })();
  </script>
{%- endif -%}
