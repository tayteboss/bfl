{{ 'header.css' | asset_url | stylesheet_tag }}

<header>
  <a class="header__logo" href="{{ routes.root_url }}"> <span>Bellows </span> <span>Film Lab</span> </a>

  <button class="menu-toggle" aria-label="Open Menu" data-text="Menu">
    Menu
    {% if cart.item_count > 0 %}
      <span class="menu-toggle__number">{{ cart.item_count }}</span>
    {% endif %}
  </button>

  <a class="cart-button cart-button--desktop" href="{{ routes.cart_url }}">
    Bag
    <div class="cart-button__bubble">
      <span class="cart-button__number">{{ cart.item_count }}</span>
    </div>
  </a>

  <div class="menu-overlay" id="menu-overlay">
    <nav class="menu-list">
      {% for link in section.settings.navigation.links %}
        <a
          class="menu-list__item{% if link.active %} menu-list__item--active{% endif %}"
          href="{{ link.url }}"
        >
          {{- link.title -}}
        </a>
      {% endfor %}
      {% if shop.customer_accounts_enabled %}
        <a
          class="menu-list__item{% if routes.account_url == request.path %} menu-list__item--active{% endif %}"
          href="{{ routes.account_url }}"
          >My Account</a
        >
      {% endif %}
    </nav>
    <a class="cart-button cart-button--mobile" href="{{ routes.cart_url }}">
      Bag
      <div class="cart-button__bubble">
        <span class="cart-button__number">{{ cart.item_count }}</span>
      </div>
    </a>
  </div>
</header>

<script>
  document.addEventListener('DOMContentLoaded', function () {
    const header = document.querySelector('header');
    const menuToggle = document.querySelector('.menu-toggle');
    const body = document.body;
    const footer = document.querySelector('.footer');
    const logoEl = document.querySelector('.header__logo');

    const MAX_RANGE_PX = 200;
    const MIN_WGHT = 50;
    const MAX_WGHT = 200;

    // Track scroll direction to hide/show the menu toggle button
    let lastScrollY = window.scrollY || window.pageYOffset || 0;
    const SCROLL_DIR_THRESHOLD = 5; // debounce small scroll jitters
    const MENU_TOGGLE_HIDDEN_CLASS = 'menu-toggle--hidden';

    let footerHeight = footer ? footer.offsetHeight : 500;

    const updateFooterHeight = () => {
      if (footer) {
        footerHeight = footer.offsetHeight + 200;
      }
    };

    const updateHideHeader = () => {
      const doc = document.documentElement;
      const scrollY = window.scrollY;
      const windowHeight = window.innerHeight;
      const documentHeight = doc.scrollHeight;
      const scrollThreshold = windowHeight * 1.5;
      const footerThreshold = footerHeight / 2;

      const distanceToBottom = documentHeight - scrollY - windowHeight;
      const isPastScrollThreshold = scrollY > scrollThreshold;
      const isNearFooter = distanceToBottom <= footerThreshold;

      const shouldHide = isPastScrollThreshold && isNearFooter;
      body.classList.toggle('hide-header', shouldHide);
    };

    // Toggle minimise-header when scrolling past MAX_RANGE_PX
    const updateMinimiseHeader = (y) => {
      const currentY = typeof y === 'number' ? y : window.scrollY || window.pageYOffset || 0;
      header.classList.toggle('minimise-header', currentY > MAX_RANGE_PX);
    };

    menuToggle.addEventListener('click', () => {
      header.classList.toggle('menu-open');
      const isOpen = header.classList.contains('menu-open');
      menuToggle.textContent = isOpen ? 'Close' : 'Menu';
      menuToggle.setAttribute('aria-label', isOpen ? 'Close Menu' : 'Open Menu');

      // Ensure the toggle remains visible while the menu is open
      if (isOpen) menuToggle.classList.remove(MENU_TOGGLE_HIDDEN_CLASS);

      // Toggle overflow hidden on body to prevent scrolling
      body.classList.toggle('overflow-hidden', isOpen);
      body.classList.toggle('menu-open', isOpen);
    });

    // Toggle `scrolled` and `minimise-header` on header when beyond threshold and hide near page bottom
    if (window.ScrollUtils && typeof window.ScrollUtils.onScroll === 'function') {
      const threshold = MAX_RANGE_PX;
      const onScrollUpdate = (y) => {
        header.classList.toggle('scrolled', y > threshold);
        updateMinimiseHeader(y);
        updateHideHeader();

        // Hide the menu toggle when scrolling down, show when scrolling up
        const currentY = typeof y === 'number' ? y : window.scrollY || window.pageYOffset || 0;
        if (header.classList.contains('menu-open')) {
          menuToggle.classList.remove(MENU_TOGGLE_HIDDEN_CLASS);
        } else {
          const diff = currentY - lastScrollY;
          if (diff > SCROLL_DIR_THRESHOLD) {
            menuToggle.classList.add(MENU_TOGGLE_HIDDEN_CLASS);
          } else if (diff < -SCROLL_DIR_THRESHOLD) {
            menuToggle.classList.remove(MENU_TOGGLE_HIDDEN_CLASS);
          }
        }
        lastScrollY = currentY;
      };
      const unsubscribe = window.ScrollUtils.onScroll(onScrollUpdate);

      // Optional: clean up if this section is dynamically replaced
      document.addEventListener('shopify:section:unload', () => {
        if (typeof unsubscribe === 'function') unsubscribe();
      });
    } else {
      const onScrollFallback = () => {
        updateMinimiseHeader();
        updateHideHeader();

        // Hide the menu toggle when scrolling down, show when scrolling up
        const currentY = window.scrollY || window.pageYOffset || 0;
        if (header.classList.contains('menu-open')) {
          menuToggle.classList.remove(MENU_TOGGLE_HIDDEN_CLASS);
        } else {
          const diff = currentY - lastScrollY;
          if (diff > SCROLL_DIR_THRESHOLD) {
            menuToggle.classList.add(MENU_TOGGLE_HIDDEN_CLASS);
          } else if (diff < -SCROLL_DIR_THRESHOLD) {
            menuToggle.classList.remove(MENU_TOGGLE_HIDDEN_CLASS);
          }
        }
        lastScrollY = currentY;
      };
      window.addEventListener('scroll', onScrollFallback, { passive: true });
      document.addEventListener('shopify:section:unload', () => {
        window.removeEventListener('scroll', onScrollFallback);
      });
    }

    window.addEventListener('resize', () => {
      updateFooterHeight();
      updateHideHeader();
    });

    updateFooterHeight();
    updateHideHeader();
    updateMinimiseHeader();

    // Step-based random weight for header logo + collapse via wdth after 500px
    if (logoEl) {
      const STEP_PX = 35;

      let lastStep = -1;
      let lastWeight = 0;
      let initialBlinkTimer = null;
      let initialBlinkActive = false;
      let scrollBlinkStopTimer = null;
      let unsubscribeScrollBlink;

      function randomInt(min, max) {
        return Math.floor(Math.random() * (max - min + 1)) + min;
      }

      function applyForY(y) {
        const clampedY = y < 0 ? 0 : y;
        if (clampedY > MAX_RANGE_PX) {
          // Collapse width to 0; keep weight driven by CSS variable
          logoEl.style.fontVariationSettings = `"wght" var(--font-weight-header), "wdth" 0`;
          return;
        }
        // Lock to 80 weight for first 50px from top
        if (clampedY < 50) {
          lastStep = Math.floor(clampedY / STEP_PX);
          lastWeight = 80;
          document.documentElement.style.setProperty('--font-weight-header', '80');
          // Clear inline overrides so stylesheet uses the variable
          logoEl.style.fontVariationSettings = '';
          return;
        }
        const step = Math.floor(clampedY / STEP_PX);
        if (step !== lastStep) {
          lastStep = step;
          lastWeight = randomInt(MIN_WGHT, MAX_WGHT);
          document.documentElement.style.setProperty('--font-weight-header', String(lastWeight));
          // Ensure we don't hold an inline override
          logoEl.style.fontVariationSettings = '';
        }
      }

      // Initialize with current position
      applyForY(window.scrollY || window.pageYOffset || 0);

      let unsubscribeLogo;
      if (window.ScrollUtils && typeof window.ScrollUtils.onScroll === 'function') {
        unsubscribeLogo = window.ScrollUtils.onScroll(applyForY);
      } else {
        const onScroll = () => applyForY(window.scrollY || window.pageYOffset || 0);
        window.addEventListener('scroll', onScroll, { passive: true });
        unsubscribeLogo = () => window.removeEventListener('scroll', onScroll);
      }

      // Cleanup when section is unloaded in the theme editor
      document.addEventListener('shopify:section:unload', () => {
        if (typeof unsubscribeLogo === 'function') unsubscribeLogo();
      });

      // Hover-driven random width variation every 0.5s while hovered
      const MIN_WDTH = 50;
      const MAX_WDTH = 200;
      let hoverTimer = null;
      let unsubscribeCursorHover;
      let onLogoEnter;
      let onLogoLeave;

      function getCurrentWeight() {
        // Use lastWeight from scroll logic to keep continuity
        return lastWeight || 80;
      }

      function startHoverRandomizer() {
        if (hoverTimer) return;
        const headerEl = document.querySelector('header');
        if (headerEl.classList.contains('menu-open')) return;
        hoverTimer = setInterval(() => {
          const yPos = window.scrollY || window.pageYOffset || 0;
          if (yPos > MAX_RANGE_PX) return; // honor collapse rule
          const wghtAmount = Math.floor(Math.random() * (MAX_WDTH - MIN_WDTH + 1)) + MIN_WDTH;
          // Persist by updating the root variable; stylesheet applies it
          document.documentElement.style.setProperty('--font-weight-header', String(wghtAmount));
          // Clear inline override if any
          if (logoEl.style.fontVariationSettings) logoEl.style.fontVariationSettings = '';
        }, 200);
      }

      function stopHoverRandomizer() {
        if (hoverTimer) {
          clearInterval(hoverTimer);
          hoverTimer = null;
        }
        // Do not restore inline style; root variable persists the last weight
      }

      function isCursorOverLogo(x, y) {
        const rect = logoEl.getBoundingClientRect();
        return x >= rect.left && x <= rect.right && y >= rect.top && y <= rect.bottom;
      }

      function ensureCursorSubscription() {
        if (unsubscribeCursorHover || !(window.CursorUtils && typeof window.CursorUtils.onMove === 'function')) return;
        unsubscribeCursorHover = window.CursorUtils.onMove(({ x, y }) => {
          const yPos = window.scrollY || window.pageYOffset || 0;
          if (yPos > MAX_RANGE_PX) {
            stopHoverRandomizer();
            return;
          }
          if (isCursorOverLogo(x, y)) {
            startHoverRandomizer();
          } else {
            stopHoverRandomizer();
          }
        });
      }

      // Try to subscribe immediately; if utility isn't ready, fall back to mousemove
      ensureCursorSubscription();
      if (!unsubscribeCursorHover) {
        const onMouseMove = (e) => {
          const yPos = window.scrollY || window.pageYOffset || 0;
          if (yPos > MAX_RANGE_PX) {
            stopHoverRandomizer();
            return;
          }
          if (isCursorOverLogo(e.clientX || 0, e.clientY || 0)) {
            startHoverRandomizer();
          } else {
            stopHoverRandomizer();
          }
        };
        window.addEventListener('mousemove', onMouseMove, { passive: true });
        unsubscribeCursorHover = () => window.removeEventListener('mousemove', onMouseMove);
      }

      // Explicit hover events to ensure blink while hovering over the logo
      onLogoEnter = () => {
        const yPos = window.scrollY || window.pageYOffset || 0;
        if (yPos <= MAX_RANGE_PX) startHoverRandomizer();
      };
      onLogoLeave = () => {
        stopHoverRandomizer();
      };
      logoEl.addEventListener('mouseenter', onLogoEnter);
      logoEl.addEventListener('mouseleave', onLogoLeave);

      // 1) Initial blink on load for 2s
      initialBlinkActive = true;
      startHoverRandomizer();
      initialBlinkTimer = setTimeout(() => {
        initialBlinkActive = false;
        stopHoverRandomizer();
      }, 2000);

      // 2) Blink while scrolling (until MAX_RANGE_PX). Stop shortly after scroll stops
      const handleScrollBlink = (y) => {
        const currentY = typeof y === 'number' ? y : window.scrollY || window.pageYOffset || 0;
        if (initialBlinkActive) {
          clearTimeout(initialBlinkTimer);
          initialBlinkActive = false;
        }
        if (currentY <= MAX_RANGE_PX) {
          startHoverRandomizer();
          clearTimeout(scrollBlinkStopTimer);
          scrollBlinkStopTimer = setTimeout(() => {
            // Only stop if not in initial blink window
            if (!initialBlinkActive) stopHoverRandomizer();
          }, 150);
        } else {
          stopHoverRandomizer();
        }
      };

      if (window.ScrollUtils && typeof window.ScrollUtils.onScroll === 'function') {
        unsubscribeScrollBlink = window.ScrollUtils.onScroll(handleScrollBlink);
      } else {
        const onScrollBlinkFallback = () => handleScrollBlink();
        window.addEventListener('scroll', onScrollBlinkFallback, { passive: true });
        unsubscribeScrollBlink = () => window.removeEventListener('scroll', onScrollBlinkFallback);
      }

      document.addEventListener('shopify:section:unload', () => {
        stopHoverRandomizer();
        if (typeof unsubscribeCursorHover === 'function') unsubscribeCursorHover();
        if (typeof unsubscribeScrollBlink === 'function') unsubscribeScrollBlink();
        if (initialBlinkTimer) clearTimeout(initialBlinkTimer);
        if (scrollBlinkStopTimer) clearTimeout(scrollBlinkStopTimer);
        if (onLogoEnter) logoEl.removeEventListener('mouseenter', onLogoEnter);
        if (onLogoLeave) logoEl.removeEventListener('mouseleave', onLogoLeave);
      });
    }

    // Keep header cart count in sync without page refresh
    if (typeof subscribe === 'function' && typeof PUB_SUB_EVENTS !== 'undefined') {
      const setHeaderCartCount = (count) => {
        const desktopEl = document.querySelector('.cart-button--desktop .cart-button__number');
        const mobileEl = document.querySelector('.cart-button--mobile .cart-button__number');
        const menuEl = document.querySelector('.menu-toggle__number');
        [desktopEl, mobileEl, menuEl].forEach((el) => {
          if (!el) return;
          el.textContent = String(count);
          el.classList.toggle('is-zero', count === 0);
        });
      };

      const onCartUpdate = (event) => {
        const count =
          event && event.cartData && typeof event.cartData.item_count === 'number' ? event.cartData.item_count : null;
        if (count === null) return;
        setHeaderCartCount(count);
      };

      const unsubscribeCartUpdate = subscribe(PUB_SUB_EVENTS.cartUpdate, onCartUpdate);
      document.addEventListener('shopify:section:unload', () => {
        if (typeof unsubscribeCartUpdate === 'function') unsubscribeCartUpdate();
      });
    }
  });
</script>

{% schema %}
{
  "name": "header",
  "settings": [
    {
      "type": "link_list",
      "id": "navigation",
      "label": "t:labels.menu"
    },
    {
      "type": "image_picker",
      "id": "logo",
      "label": "logo"
    }
  ]
}
{% endschema %}
